"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const ts = require("typescript");
const get_value_or_default_1 = require("./helpers/get-value-or-default");
const tsconfig_paths_hook_1 = require("./hooks/tsconfig-paths.hook");
class Compiler {
    constructor(pluginsLoader, tsConfigProvider) {
        this.pluginsLoader = pluginsLoader;
        this.tsConfigProvider = tsConfigProvider;
        this.formatHost = {
            getCanonicalFileName: path => path,
            getCurrentDirectory: ts.sys.getCurrentDirectory,
            getNewLine: () => ts.sys.newLine,
        };
    }
    run(configuration, configFilename, appName, onSuccess) {
        const { options, fileNames, projectReferences, } = this.tsConfigProvider.getByConfigFilename(configFilename);
        const createProgram = ts.createIncrementalProgram || ts.createProgram;
        const program = createProgram.call(ts, {
            rootNames: fileNames,
            projectReferences,
            options,
        });
        const pluginsConfig = get_value_or_default_1.getValueOrDefault(configuration, 'compilerOptions.plugins', appName);
        const plugins = this.pluginsLoader.load(pluginsConfig);
        const tsconfigPathsPlugin = tsconfig_paths_hook_1.tsconfigPathsBeforeHookFactory(options);
        const programRef = program.getProgram
            ? program.getProgram()
            : program;
        const before = plugins.beforeHooks.map(hook => hook(programRef));
        const after = plugins.afterHooks.map(hook => hook(programRef));
        const emitResult = program.emit(undefined, undefined, undefined, undefined, {
            before: before.concat(tsconfigPathsPlugin),
            after,
            afterDeclarations: [],
        });
        const errorsCount = this.reportAfterCompilationDiagnostic(program, emitResult);
        if (errorsCount) {
            process.exit(1);
        }
        else if (!errorsCount && onSuccess) {
            onSuccess();
        }
    }
    reportAfterCompilationDiagnostic(program, emitResult) {
        const diagnostics = ts
            .getPreEmitDiagnostics(program)
            .concat(emitResult.diagnostics);
        if (diagnostics.length > 0) {
            console.error(ts.formatDiagnosticsWithColorAndContext(diagnostics, this.formatHost));
            console.info(`Found ${diagnostics.length} error(s).` + ts.sys.newLine);
        }
        return diagnostics.length;
    }
}
exports.Compiler = Compiler;
