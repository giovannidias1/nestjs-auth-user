"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = require("path");
const tsPaths = require("tsconfig-paths");
const ts = require("typescript");
function tsconfigPathsBeforeHookFactory(compilerOptions) {
    const { paths = {}, baseUrl = './' } = compilerOptions;
    const matcher = tsPaths.createMatchPath(baseUrl, paths, ['main']);
    return (ctx) => {
        return (sf) => {
            const visitNode = (node) => {
                if (ts.isImportDeclaration(node) ||
                    (ts.isExportDeclaration(node) && node.moduleSpecifier)) {
                    const newNode = ts.getMutableClone(node);
                    const importPathWithQuotes = node.moduleSpecifier && node.moduleSpecifier.getText();
                    if (!importPathWithQuotes) {
                        return node;
                    }
                    const text = importPathWithQuotes.substr(1, importPathWithQuotes.length - 2);
                    const result = getNotAliasedPath(sf, matcher, text);
                    if (!result) {
                        return node;
                    }
                    newNode.moduleSpecifier = ts.createLiteral(result);
                    return newNode;
                }
                return ts.visitEachChild(node, visitNode, ctx);
            };
            return ts.visitNode(sf, visitNode);
        };
    };
}
exports.tsconfigPathsBeforeHookFactory = tsconfigPathsBeforeHookFactory;
function getNotAliasedPath(sf, matcher, text) {
    const result = matcher(text, undefined, undefined, ['.ts', '.js']);
    if (!result) {
        return;
    }
    const resolvedPath = path_1.posix.relative(path_1.dirname(sf.fileName), result) || './';
    return resolvedPath[0] === '.' ? resolvedPath : './' + resolvedPath;
}
